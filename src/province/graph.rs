// src/province/graph.rs
//! Граф смежности провинций
//!
//! Этот модуль строит неориентированный граф смежности между провинциями мира.
//! Граф используется для:
//! - Определения соседних провинций (дипломатия, войны)
//! - Поиска маршрутов (торговля, передвижение армий)
//! - Анализа связности мира (континенты, архипелаги)
//! - Группировки провинций в регионы
//!
//! ## Алгоритм построения
//!
//! 1. **Инициализация узлов**:
//!    - Каждая провинция становится узлом графа
//!    - Узел содержит `province_id` как полезную нагрузку
//!
//! 2. **Сканирование границ**:
//!    - Проходим по каждому пикселю карты
//!    - Для каждого пикселя проверяем 4 ортогональных соседа (без диагоналей)
//!    - Бесшовная обработка по долготе (карта "заворачивается" по горизонтали)
//!    - Вертикальные границы обрабатываются с отражением (полюса)
//!
//! 3. **Добавление рёбер**:
//!    - Если соседний пиксель принадлежит другой провинции → потенциальное ребро
//!    - Используем `HashSet` для избежания дубликатов рёбер
//!    - Рёбра не имеют веса (все границы равнозначны)
//!
//! ## Особенности реализации
//!
//! - **4-связность**: используется только ортогональная смежность (как в генерации провинций)
//! - **Детерминированность**: граф идентичен для одинаковых входных данных
//! - **Эффективность**: сложность O(width × height) с минимальными накладными расходами
//! - **Бесшовность**: корректная обработка границ карты по долготе
//!
//! ## Пример использования
//!
//! ```rust
//! // Построение графа
//! let graph = build_province_graph_with_map(
//!     &provinces,
//!     &pixel_to_id,
//!     width,
//!     height,
//! );
//!
//! // Поиск соседей провинции с id=42
//! let node_idx = graph.node_indices()
//!     .find(|&n| graph[n] == 42)
//!     .unwrap();
//!
//! let neighbors: Vec<u32> = graph.neighbors(node_idx)
//!     .map(|n| graph[n])
//!     .collect();
//! ```

use crate::province::Province;
use petgraph::graph::UnGraph;
use std::collections::{HashMap, HashSet};

// 4 ортогональных направления (без диагоналей) — соответствует алгоритму генерации провинций
const DIRECTIONS: [(i32, i32); 4] = [(0, 1), (1, 0), (0, -1), (-1, 0)];

/// Строит граф смежности провинций на основе карты пикселей
///
/// # Алгоритм
/// 1. Создаёт узел графа для каждой провинции из списка `provinces`
/// 2. Сканирует каждый пиксель карты и его 4 ортогональных соседа:
///    - Если сосед принадлежит другой провинции → добавляет ребро
///    - Использует `HashSet` для предотвращения дублирования рёбер
/// 3. Обеспечивает бесшовность по долготе через `rem_euclid`
///
/// # Параметры
/// * `provinces` — список всех провинций мира (должен содержать все `province_id` из `pixel_to_id`)
/// * `pixel_to_id` — карта пикселей, где каждый элемент — `province_id` (размер: `width × height`)
/// * `width` — ширина карты в пикселях
/// * `height` — высота карты в пикселях
///
/// # Возвращает
/// Неориентированный граф `UnGraph<u32, ()>`, где:
/// - Узлы содержат `province_id` (тип `u32`)
/// - Рёбра не имеют полезной нагрузки (тип `()`)
/// - Каждое ребро представляет общую границу между двумя провинциями
///
/// # Гарантии
/// - Граф содержит узел для каждой провинции из `provinces`
/// - Рёбра добавляются только между разными провинциями
/// - Каждая пара провинций соединена не более чем одним ребром
/// - Бесшовная обработка по долготе (восточная граница соединяется с западной)
///
/// # Особенности
/// - Вертикальные границы (полюса) обрабатываются с отражением (`clamp`)
/// - Диагональные соседи игнорируются (только 4-связность)
/// - Пиксели с `u32::MAX` пропускаются (защита от некорректных данных)
///
/// # Пример
/// ```rust
/// let graph = build_province_graph_with_map(
///     &all_provinces,
///     &pixel_to_id,
///     1024,
///     512,
/// );
///
/// // Количество провинций в графе
/// assert_eq!(graph.node_count(), all_provinces.len());
///
/// // Провинция 0 имеет хотя бы одного соседа
/// let node_0 = graph.node_indices().find(|&n| graph[n] == 0).unwrap();
/// assert!(graph.neighbors(node_0).next().is_some());
/// ```
#[must_use]
pub fn build_province_graph_with_map(
    provinces: &[Province],
    pixel_to_id: &[u32],
    width: u32,
    height: u32,
) -> UnGraph<u32, ()> {
    let mut graph = UnGraph::new_undirected();
    let mut id_to_node = HashMap::new();

    // Добавляем узлы для всех провинций
    for province in provinces {
        let node = graph.add_node(province.id);
        id_to_node.insert(province.id, node);
    }

    let mut edges = HashSet::new();

    // Сканируем каждый пиксель для обнаружения границ между провинциями
    for y in 0..height {
        for x in 0..width {
            let idx = (y * width + x) as usize;
            let current_id = pixel_to_id[idx];

            // Защита от некорректных данных (в правильно сгенерированной карте не должно встречаться)
            if current_id == u32::MAX {
                continue;
            }

            // Проверяем 4 ортогональных соседа
            for &(dx, dy) in &DIRECTIONS {
                // Бесшовная обработка по долготе (ось X)
                let nx = (x as i32 + dx).rem_euclid(width as i32) as u32;
                // Отражение на полюсах (ось Y)
                let ny = (y as i32 + dy).clamp(0, height as i32 - 1) as u32;
                let nidx = (ny * width + nx) as usize;
                let neighbor_id = pixel_to_id[nidx];

                // Пропускаем недействительные или одинаковые ID
                if neighbor_id == u32::MAX || neighbor_id == current_id {
                    continue;
                }

                // Создаём упорядоченную пару для избежания дубликатов рёбер
                let (a, b) = if current_id < neighbor_id {
                    (current_id, neighbor_id)
                } else {
                    (neighbor_id, current_id)
                };

                // Добавляем ребро, если его ещё нет
                if edges.insert((a, b))
                    && let (Some(&node_a), Some(&node_b)) = (id_to_node.get(&a), id_to_node.get(&b))
                {
                    graph.add_edge(node_a, node_b, ());
                }
            }
        }
    }

    graph
}
