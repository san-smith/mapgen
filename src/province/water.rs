// src/province/water.rs
//! Классификация водных поверхностей
//!
//! Этот модуль разделяет водные пиксели на два типа:
//! - **Океаны** — водные массы, соединённые с краями карты (мировой океан)
//! - **Озёра** — замкнутые водоёмы, полностью окружённые сушей
//!
//! ## Алгоритм классификации
//!
//! 1. **Инициализация**:
//!    - Все пиксели изначально помечаются как `Land`
//!    - Создаётся карта посещённых пикселей для алгоритма BFS
//!
//! 2. **Поиск океанов через BFS**:
//!    - Стартуем с водных пикселей на краях карты:
//!      - Верхняя и нижняя границы (полюса)
//!      - Левая и правая границы (с учётом бесшовности по долготе)
//!    - Распространяемся по водным пикселям через 4-направленный BFS
//!    - Все достигнутые водные пиксели помечаются как `Ocean`
//!
//! 3. **Классификация озёр**:
//!    - Все оставшиеся водные пиксели (не достигнутые BFS) помечаются как `Lake`
//!
//! ## Особенности реализации
//!
//! - **Бесшовность по долготе**: левый и правый края карты соединены (цилиндрическая проекция)
//!   - Используется `rem_euclid` для корректного перехода через меридиан
//! - **Обработка полюсов**: верхняя и нижняя границы НЕ соединены (реалистично для земного шара)
//!   - Используется `clamp` для ограничения по широте
//! - **4-направленный поиск**: согласованность с алгоритмами генерации провинций
//! - **Эффективность**: один проход BFS + один линейный проход = O(width × height)
//!
//! ## Геймплейное значение
//!
//! - **Океаны**:
//!   - Используются для генерации морских провинций
//!   - Поддерживают морскую торговлю и навигацию
//!   - Могут содержать айсберги и ледяные поля в полярных зонах
//! - **Озёра**:
//!   - Рассматриваются как часть сухопутных провинций
//!   - Дают бонусы к сельскому хозяйству и населению
//!   - Не поддерживают морскую навигацию (внутренние водоёмы)
//!
//! ## Пример использования
//! ```rust
//! let water_type = classify_water(&heightmap, 0.5);
//!
//! // Подсчёт типов
//! let ocean_count = water_type.iter().filter(|&&t| t == WaterType::Ocean).count();
//! let lake_count = water_type.iter().filter(|&&t| t == WaterType::Lake).count();
//! let land_count = water_type.iter().filter(|&&t| t == WaterType::Land).count();
//! ```

use crate::heightmap::Heightmap;
use std::collections::VecDeque;

/// Тип водной поверхности
///
/// Определяет географическую и геймплейную принадлежность водного пикселя.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum WaterType {
    /// Мировой океан — водная масса, соединённая с краями карты
    ///
    /// Характеристики:
    /// - Бесконечная водная поверхность (в рамках карты)
    /// - Используется для генерации морских провинций
    /// - Поддерживает морскую навигацию и торговлю
    /// - Может содержать острова и архипелаги
    ///
    /// Географические примеры: Атлантический океан, Тихий океан
    Ocean,

    /// Замкнутое озеро — водная масса, полностью окружённая сушей
    ///
    /// Характеристики:
    /// - Ограниченная водная поверхность
    /// - Рассматривается как часть сухопутной провинции
    /// - Не поддерживает морскую навигацию (только речную/озёрную)
    /// - Даёт бонусы к сельскому хозяйству и населению
    ///
    /// Географические примеры: озеро Байкал, Великие озёра
    Lake,

    /// Суша — пиксель выше уровня моря
    ///
    /// Характеристики:
    /// - Поддерживает все типы сухопутной инфраструктуры
    /// - Может быть прибрежным или внутренним
    /// - Определяет тип провинции (континент/остров)
    Land,
}

/// 4 ортогональных направления для поиска в ширину (без диагоналей)
///
/// Используется для согласованности с алгоритмами генерации провинций
/// и обеспечения естественных границ между водными массами.
const DIRECTIONS: [(i32, i32); 4] = [(0, 1), (1, 0), (0, -1), (-1, 0)];

/// Классифицирует водные пиксели на океаны и озёра
///
/// # Алгоритм
/// 1. **Инициализация**:
///    - Создаётся вектор `water_type` размером `width × height`, заполненный `Land`
///    - Создаётся вектор `visited` для отслеживания посещённых пикселей
///
/// 2. **Сбор стартовых точек для BFS**:
///    - Все водные пиксели на верхней и нижней границах (полюса) добавляются в очередь
///    - Все водные пиксели на левой и правой границах добавляются в очередь
///      (с учётом бесшовности: левый и правый края соединены)
///
/// 3. **BFS от краёв**:
///    - Для каждого пикселя из очереди проверяются 4 ортогональных соседа
///    - Бесшовность по долготе: `nx = (x + dx).rem_euclid(width as i32)`
///    - Ограничение по широте: `ny = (y + dy).clamp(0, height - 1)`
///    - Водные непосещённые соседи помечаются как `Ocean` и добавляются в очередь
///
/// 4. **Классификация озёр**:
///    - Все оставшиеся водные пиксели (не достигнутые BFS) помечаются как `Lake`
///
/// # Параметры
/// * `heightmap` — карта высот для определения водных пикселей
/// * `sea_level` — уровень моря (обычно 0.5), пиксели ниже этого уровня считаются водой
///
/// # Возвращает
/// Вектор `WaterType` размером `width × height`, где каждый элемент соответствует типу пикселя.
///
/// # Особенности
/// - **Бесшовность по долготе**: корректная обработка перехода через меридиан (180°)
/// - **Реалистичная география**: озёра формируются только в замкнутых котловинах
/// - **Детерминированность**: результат зависит только от `heightmap` и `sea_level`
/// - **Эффективность**: два прохода по карте (BFS + финальная классификация)
///
/// # Пример
/// ```rust
/// let water_type = classify_water(&heightmap, 0.5);
///
/// // Проверка типа пикселя в координатах (100, 200)
/// let idx = 200 * heightmap.width as usize + 100;
/// match water_type[idx] {
///     WaterType::Ocean => println!("Мировой океан"),
///     WaterType::Lake => println!("Озеро"),
///     WaterType::Land => println!("Суша"),
/// }
/// ```
#[must_use]
pub fn classify_water(heightmap: &Heightmap, sea_level: f32) -> Vec<WaterType> {
    let width = heightmap.width as usize;
    let height = heightmap.height as usize;
    let total = width * height;

    let mut water_type = vec![WaterType::Land; total];
    let mut visited = vec![false; total];

    // Очередь для BFS: (x, y)
    let mut queue = VecDeque::new();

    // === ШАГ 1: Сбор стартовых точек на краях карты ===

    // Верхняя и нижняя границы (полюса) — НЕ бесшовные
    for x in 0..width {
        // Верхняя граница (северный полюс)
        let top_idx = x;
        if heightmap.data[top_idx] < sea_level && !visited[top_idx] {
            water_type[top_idx] = WaterType::Ocean;
            visited[top_idx] = true;
            queue.push_back((x as i32, 0));
        }

        // Нижняя граница (южный полюс)
        let bottom_idx = (height - 1) * width + x;
        if heightmap.data[bottom_idx] < sea_level && !visited[bottom_idx] {
            water_type[bottom_idx] = WaterType::Ocean;
            visited[bottom_idx] = true;
            queue.push_back((x as i32, height as i32 - 1));
        }
    }

    // Левая и правая границы — БЕСШОВНЫЕ (соединены по долготе)
    for y in 0..height {
        // Левая граница
        let left_idx = y * width;
        if heightmap.data[left_idx] < sea_level && !visited[left_idx] {
            water_type[left_idx] = WaterType::Ocean;
            visited[left_idx] = true;
            queue.push_back((0, y as i32));
        }

        // Правая граница
        let right_idx = y * width + (width - 1);
        if heightmap.data[right_idx] < sea_level && !visited[right_idx] {
            water_type[right_idx] = WaterType::Ocean;
            visited[right_idx] = true;
            queue.push_back((width as i32 - 1, y as i32));
        }
    }

    // === ШАГ 2: BFS от краёв для распространения океана ===
    while let Some((x, y)) = queue.pop_front() {
        for &(dx, dy) in &DIRECTIONS {
            // Бесшовность по долготе (ось X)
            let nx = (x + dx).rem_euclid(width as i32);
            // Ограничение по широте (ось Y) — полюса не соединены
            let ny = (y + dy).clamp(0, height as i32 - 1);
            let nidx = ny as usize * width + nx as usize;

            if !visited[nidx] && heightmap.data[nidx] < sea_level {
                water_type[nidx] = WaterType::Ocean;
                visited[nidx] = true;
                queue.push_back((nx, ny));
            }
        }
    }

    // === ШАГ 3: Классификация оставшихся водных пикселей как озёр ===
    #[allow(clippy::needless_range_loop)]
    for i in 0..total {
        if heightmap.data[i] < sea_level && water_type[i] == WaterType::Land {
            water_type[i] = WaterType::Lake;
        }
    }

    water_type
}
