// src/region/mod.rs
//! Система регионов мира
//!
//! Этот модуль реализует группировку провинций в крупные административные единицы — регионы.
//! Регионы используются для:
//! - Упрощения управления в геймплее (объединение провинций под одним правителем)
//! - Формирования культурных и экономических зон
//! - Оптимизации вычислений (движение армий, торговля на уровне регионов)
//! - Создания естественных географических зон (континенты, морские бассейны)
//!
//! ## Алгоритм группировки
//!
//! 1. **Инициализация**:
//!    - Каждая непокрытая провинция становится центром нового региона
//!    - Регионы разделены по типу поверхности (суша/море) — смешение запрещено
//!
//! 2. **Расширение региона через BFS**:
//!    - Используется граф смежности провинций для поиска соседей
//!    - Добавляются соседние провинции того же типа поверхности (суша→суша, море→море)
//!    - Расширение продолжается до достижения `target_size` или исчерпания соседей
//!
//! 3. **Финализация региона**:
//!    - Генерируется уникальный цвет через хеширование `region_id`
//!    - Формируется название на основе типа поверхности (`Land_0`, `Sea_1`, ...)
//!    - Регион добавляется в список результатов
//!
//! ## Особенности реализации
//!
//! - **Разделение по типу поверхности**: суша и море никогда не смешиваются в одном регионе
//!   - Обеспечивает географическую реалистичность (континенты ≠ океаны)
//!   - Упрощает геймплейные механики (торговля, дипломатия)
//! - **Связность регионов**: каждый регион представляет собой связную компоненту графа
//!   - Гарантируется алгоритмом BFS по графу смежности
//!   - Исключает "островные" провинции внутри региона
//! - **Детерминированность**: цвет и порядок регионов зависят только от `region_id`
//!   - Обеспечивает воспроизводимость между запусками с одинаковым сидом
//! - **Гибкий размер**: параметр `target_size` позволяет настраивать детализацию регионов
//!
//! ## Геймплейное значение
//!
//! - **Континентальные регионы** (`is_land = true`):
//!   - Объединяют провинции одного континента или крупного острова
//!   - Формируют культурные зоны (например, "Западная Европа", "Восточная Азия")
//!   - Упрощают управление империями в стратегических играх
//!
//! - **Морские регионы** (`is_land = false`):
//!   - Объединяют провинции одного океана или морского бассейна
//!   - Определяют морские торговые пути и зоны влияния флотов
//!   - Позволяют моделировать морские державы (например, "Средиземноморье", "Карибский бассейн")
//!
//! ## Пример использования
//! ```rust
//! // Построение графа смежности
//! let graph = build_province_graph_with_map(&provinces, &pixel_to_id, width, height);
//!
//! // Группировка в регионы (целевой размер = 8 провинций)
//! let regions = group_provinces_into_regions(&provinces, &graph, 8);
//!
//! // Сохранение карты регионов
//! let region_map = RegionMap::from_pixel_map(width, height, &pixel_to_id, &regions);
//! region_map.save_as_png(&regions, "output/regions.png")?;
//! ```

pub mod png;

use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};

/// Регион — крупная административная единица, объединяющая провинции
///
/// Регион представляет собой связную группу провинций одного типа поверхности
/// (только суша или только море), объединённых общими географическими или
/// культурными характеристиками.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Region {
    /// Уникальный идентификатор региона
    ///
    /// Идентификаторы назначаются последовательно при генерации и сохраняются
    /// между запусками с одинаковым сидом для обеспечения детерминированности.
    pub id: u32,

    /// Название региона
    ///
    /// Генерируется автоматически на основе:
    /// - Типа поверхности (`Land` для суши, `Sea` для моря)
    /// - Порядкового номера региона
    ///
    /// Формат по умолчанию: `"Land_{id}"` или `"Sea_{id}"`.
    /// В будущем может быть заменено на осмысленное название через культуру.
    ///
    /// Примеры:
    /// - `"Land_0"` — первый континентальный регион
    /// - `"Sea_3"` — четвёртый морской регион
    pub name: String,

    /// Цвет региона в формате HEX
    ///
    /// Формат: `"#rrggbb"` (например, `"#a1b2c3"`)
    /// Цвет генерируется детерминированно на основе `id` через хеширование:
    /// - Одинаковый `id` → одинаковый цвет
    /// - Цвета достаточно контрастны для визуального различения
    /// - Диапазон 50-205 для каждого канала обеспечивает хороший контраст
    ///
    /// Используется для визуализации регионов на карте (`regions.png`).
    pub color: String, // "#rrggbb"

    /// Список идентификаторов провинций, входящих в регион
    ///
    /// Порядок провинций не гарантируется.
    /// Все провинции в списке:
    /// - Имеют одинаковый тип поверхности (`is_land`)
    /// - Образуют связную компоненту в графе смежности
    /// - Принадлежат только этому региону (нет пересечений между регионами)
    pub province_ids: Vec<u32>,
}

/// Генерирует детерминированный цвет для региона на основе его идентификатора
///
/// # Алгоритм
/// 1. Хешируем `region_id` через `DefaultHasher`
/// 2. Извлекаем компоненты RGB из хеша:
///    - Красный: биты 16-23
///    - Зелёный: биты 8-15
///    - Синий: биты 0-7
/// 3. Смещаем в диапазон 50-205 для обеспечения хорошего контраста:
///    ```text
///    r = (hash >> 16) % 156 + 50  // 50..205
///    g = (hash >> 8) % 156 + 50   // 50..205
///    b = hash % 156 + 50          // 50..205
///    ```
/// 4. Форматируем как HEX-строку `"#rrggbb"`
///
/// # Гарантии
/// - Одинаковый `region_id` → одинаковый цвет (детерминированность)
/// - Цвета достаточно контрастны для визуального различения
/// - Избегаем слишком тёмных (`<50`) и слишком светлых (`>205`) оттенков
///
/// # Пример
/// ```rust
/// let color = hash_region_color(42);
/// assert!(color.starts_with('#'));
/// assert_eq!(color.len(), 7);
/// ```
fn hash_region_color(region_id: u32) -> String {
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};

    let mut hasher = DefaultHasher::new();
    region_id.hash(&mut hasher);
    let hash = hasher.finish();
    let r = ((hash >> 16) % 156) as u8 + 50;
    let g = ((hash >> 8) % 156) as u8 + 50;
    let b = (hash % 156) as u8 + 50;
    format!("#{r:02x}{g:02x}{b:02x}")
}

/// Группирует провинции в регионы на основе графа смежности
///
/// # Алгоритм
/// 1. **Инициализация**:
///    - Создаётся пустой список регионов
///    - Создаётся множество `assigned` для отслеживания покрытых провинций
///    - Строятся маппинги `prov_map` (id → провинция) и `node_map` (id → узел графа)
///
/// 2. **Итерация по провинциям**:
///    - Каждая непокрытая провинция становится центром нового региона
///    - Определяется тип поверхности региона (`is_land_reg`) на основе центральной провинции
///
/// 3. **Расширение региона через BFS**:
///    - Инициализируется очередь с центральной провинцией
///    - Пока размер региона < `target_size` и очередь не пуста:
///      - Извлекается провинция из очереди
///      - Для каждого соседа в графе смежности:
///        - Проверяется непокрытость и соответствие типа поверхности
///        - При успехе: провинция добавляется в регион и очередь
///
/// 4. **Финализация региона**:
///    - Генерируется название: `"Land_{id}"` или `"Sea_{id}"`
///    - Генерируется цвет через `hash_region_color(region_id)`
///    - Регион добавляется в список результатов
///    - `region_id_counter` инкрементируется
///
/// # Параметры
/// * `provinces` — список всех провинций мира
/// * `graph` — граф смежности провинций (`UnGraph<u32, ()>`)
/// * `target_size` — целевой размер региона в провинциях (рекомендуется 6-12)
///
/// # Возвращает
/// Вектор структур `Region`, покрывающий все провинции из `provinces`.
///
/// # Гарантии
/// - Каждая провинция принадлежит ровно одному региону
/// - Все регионы связны (через граф смежности)
/// - Суша и море никогда не смешиваются в одном регионе
/// - Алгоритм детерминирован для одинаковых входных данных
///
/// # Особенности
/// - **Тип поверхности**: регион наследует тип от первой провинции (центра)
/// - **Размер региона**: может быть меньше `target_size`, если закончились соседи
/// - **Порядок регионов**: зависит от порядка провинций в `provinces`
///
/// # Пример
/// ```rust
/// let regions = group_provinces_into_regions(
///     &all_provinces,
///     &graph,
///     8, // целевой размер: 8 провинций на регион
/// );
///
/// // Проверка покрытия
/// let total_provinces: usize = regions.iter().map(|r| r.province_ids.len()).sum();
/// assert_eq!(total_provinces, all_provinces.len());
///
/// // Проверка разделения суша/море
/// for region in &regions {
///     let first_prov = &all_provinces.iter().find(|p| p.id == region.province_ids[0]).unwrap();
///     for &pid in &region.province_ids[1..] {
///         let prov = &all_provinces.iter().find(|p| p.id == pid).unwrap();
///         assert_eq!(prov.is_land, first_prov.is_land);
///     }
/// }
/// ```
#[allow(clippy::missing_panics_doc)]
#[must_use]
pub fn group_provinces_into_regions(
    provinces: &[crate::province::Province],
    graph: &petgraph::graph::UnGraph<u32, ()>,
    target_size: usize,
) -> Vec<Region> {
    let mut regions = Vec::new();
    let mut assigned = HashSet::new();
    let prov_map: HashMap<u32, &crate::province::Province> =
        provinces.iter().map(|p| (p.id, p)).collect();
    let node_map: HashMap<u32, petgraph::graph::NodeIndex> =
        graph.node_indices().map(|idx| (graph[idx], idx)).collect();

    let mut region_id_counter = 0;

    for province in provinces {
        if assigned.contains(&province.id) {
            continue;
        }

        let is_land_reg = province.is_land;
        let mut reg_pids = vec![province.id];
        assigned.insert(province.id);

        let mut queue = std::collections::VecDeque::new();
        queue.push_back(province.id);

        while reg_pids.len() < target_size && !queue.is_empty() {
            let curr_id = queue.pop_front().unwrap();
            if let Some(&node_idx) = node_map.get(&curr_id) {
                for neighbor_idx in graph.neighbors(node_idx) {
                    let n_id = graph[neighbor_idx];
                    if !assigned.contains(&n_id)
                        && let Some(n_prov) = prov_map.get(&n_id)
                        && n_prov.is_land == is_land_reg
                    {
                        assigned.insert(n_id);
                        reg_pids.push(n_id);
                        queue.push_back(n_id);
                        if reg_pids.len() >= target_size {
                            break;
                        }
                    }
                }
            }
        }

        regions.push(Region {
            id: region_id_counter,
            name: format!(
                "{}_{}",
                if is_land_reg { "Land" } else { "Sea" },
                region_id_counter
            ),
            color: hash_region_color(region_id_counter),
            province_ids: reg_pids,
        });
        region_id_counter += 1;
    }
    regions
}
