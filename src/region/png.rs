// src/region/png.rs
//! Визуализация регионов в изображение
//!
//! Этот модуль преобразует данные регионов в визуальное представление:
//! - Карту пикселей → `province_id` в карту пикселей → `region_id`
//! - Цвета регионов берутся из их уникальных цветов (`Region::color`)
//! - Поддержка сохранения в PNG для отладки и экспорта
//!
//! ## Архитектура
//!
//! 1. **Преобразование провинции → регион**:
//!    - Строится маппинг `province_id → region_id` на основе `Region::province_ids`
//!    - Каждый пиксель из `pixel_to_id` преобразуется в `region_id` через маппинг
//!    - Некорректные `province_id` получают `region_id = 0` (защита от ошибок)
//!
//! 2. **Конвертация в изображение**:
//!    - Строится маппинг `region_id → RGBA` на основе цветов из `Region::color`
//!    - Каждый пиксель преобразуется в 4 байта (R, G, B, A)
//!    - Неизвестные `region_id` получают тёмно-синий цвет (`[20, 20, 60, 255]`) для визуального выделения
//!
//! 3. **Сохранение в PNG**:
//!    - Используется библиотека `image` для создания и записи изображения
//!    - Поддержка альфа-канала (всегда 255 = непрозрачный)
//!
//! ## Особенности реализации
//!
//! - **Двухэтапное преобразование**: `пиксель → провинция → регион`
//!   - Позволяет использовать существующую карту `pixel_to_id` без перегенерации
//!   - Упрощает интеграцию с существующим конвейером генерации
//! - **Безопасность**: защита от некорректных `province_id` через цвет по умолчанию
//!   - Тёмно-синий цвет (`[20, 20, 60]`) визуально выделяет проблемные области
//!   - В правильно сгенерированной карте все пиксели должны иметь корректные регионы
//! - **Эффективность**: однократное построение маппингов перед рендерингом
//! - **Согласованность**: цвета регионов совпадают с `Region::color` для детерминированности
//!
//! ## Пример использования
//! ```rust
//! // Генерация провинций и регионов
//! let (provinces, pixel_to_id) = generate_provinces_from_seeds(...);
//! let graph = build_province_graph_with_map(&provinces, &pixel_to_id, width, height);
//! let regions = group_provinces_into_regions(&provinces, &graph, 8);
//!
//! // Создание карты регионов
//! let region_map = RegionMap::from_pixel_map(
//!     width,
//!     height,
//!     &pixel_to_id,
//!     &regions,
//! );
//!
//! // Сохранение в PNG
//! region_map.save_as_png("output/regions.png", &regions)?;
//! ```

use std::collections::HashMap;

use crate::region::Region;
use image::{ImageBuffer, Rgba};

/// Карта регионов — пространственное распределение регионов по карте
///
/// Содержит сырые данные о принадлежности каждого пикселя к региону.
/// Цвета регионов не хранятся напрямую — они берутся из внешнего списка `Region`.
#[derive(Debug, Clone)]
pub struct RegionMap {
    /// Ширина карты в пикселях
    pub width: u32,

    /// Высота карты в пикселях
    pub height: u32,

    /// Данные карты: вектор `region_id` размером `width × height`
    ///
    /// Каждый элемент — идентификатор региона (`u32`), которому принадлежит пиксель.
    /// Индекс вычисляется как `y * width + x`.
    ///
    /// # Гарантии
    /// - Все пиксели имеют корректный `region_id` (после преобразования из `province_id`)
    /// - `region_id` соответствует одному из регионов в списке `regions`
    pub data: Vec<u32>, // region_id
}

impl RegionMap {
    /// Создаёт карту регионов из карты пикселей → `province_id`
    ///
    /// # Алгоритм преобразования
    /// 1. Строит маппинг `province_id → region_id`:
    ///    ```text
    ///    для каждого региона в regions:
    ///        для каждого province_id в регионе.province_ids:
    ///            маппинг[province_id] = регион.id
    ///    ```
    /// 2. Преобразует каждый пиксель из `pixel_to_id`:
    ///    - Если `province_id` найден в маппинге → используем соответствующий `region_id`
    ///    - Если `province_id == u32::MAX` или не найден → используем `0` (регион по умолчанию)
    ///
    /// # Параметры
    /// * `width` — ширина карты в пикселях
    /// * `height` — высота карты в пикселях
    /// * `pixel_to_id` — срез длиной `width × height`, где каждый элемент — `province_id`
    /// * `regions` — список регионов для построения маппинга `province_id → region_id`
    ///
    /// # Возвращает
    /// Новую структуру `RegionMap` с преобразованными данными.
    ///
    /// # Особенности
    /// - **Двухэтапное преобразование**: пиксель → провинция → регион
    /// - **Безопасность**: некорректные `province_id` получают `region_id = 0`
    /// - **Эффективность**: однократное построение маппинга перед обработкой всех пикселей
    ///
    /// # Пример
    /// ```rust
    /// let pixel_to_id = vec![0, 0, 1, 1, 2, 2, 3, 3]; // 2×4 карта провинций
    /// let regions = vec![
    ///     Region { id: 0, province_ids: vec![0, 1], .. },
    ///     Region { id: 1, province_ids: vec![2, 3], .. },
    /// ];
    /// let map = RegionMap::from_pixel_map(2, 4, &pixel_to_id, &regions);
    /// // Результат: [0, 0, 0, 0, 1, 1, 1, 1] — карта регионов
    /// ```
    #[must_use]
    pub fn from_pixel_map(
        width: u32,
        height: u32,
        pixel_to_id: &[u32],
        regions: &[Region],
    ) -> Self {
        // Создаём маппинг province_id → region_id
        let mut province_to_region = HashMap::new();
        for region in regions {
            for &pid in &region.province_ids {
                province_to_region.insert(pid, region.id);
            }
        }

        // Заполняем карту регионов через преобразование
        let data: Vec<u32> = pixel_to_id
            .iter()
            .map(|&pid| {
                // Защита от некорректных данных:
                // - u32::MAX означает "непокрытый пиксель" (не должно встречаться)
                // - Отсутствующий в маппинге province_id — ошибка генерации
                // В обоих случаях используем регион 0 как "регион по умолчанию"
                *province_to_region.get(&pid).unwrap_or(&0)
            })
            .collect();

        Self {
            width,
            height,
            data,
        }
    }

    /// Преобразует карту регионов в RGBA-изображение для визуализации
    ///
    /// # Алгоритм
    /// 1. Строит маппинг `region_id → [R, G, B, A]` на основе цветов из `regions`:
    ///    - Извлекает компоненты из HEX-строки (`"#rrggbb"` → `[r, g, b, 255]`)
    ///    - Игнорирует некорректные цвета (но в валидных данных их не должно быть)
    /// 2. Для каждого пикселя в `data`:
    ///    - Ищет цвет в маппинге по `region_id`
    ///    - Если не найден — использует тёмно-синий цвет (`[20, 20, 60, 255]`)
    ///      для визуального выделения проблемных областей
    /// 3. Формирует плоский вектор байт в порядке `[R, G, B, A, R, G, B, A, ...]`
    ///
    /// # Параметры
    /// * `regions` — список регионов для получения цветов
    ///
    /// # Возвращает
    /// Вектор байт длиной `width × height × 4`, готовый для создания изображения.
    ///
    /// # Особенности
    /// - **Эффективность**: маппинг строится один раз перед обработкой всех пикселей
    /// - **Безопасность**: тёмно-синий цвет для неизвестных ID помогает обнаружить ошибки
    ///   - В отличие от чёрного (`[0, 0, 0]`), тёмно-синий лучше виден на карте
    ///   - Цвет `[20, 20, 60]` достаточно тёмный, но отличим от чёрного
    /// - **Согласованность**: цвета совпадают с `Region::color` для детерминированности
    ///
    /// # Пример
    /// ```rust
    /// let rgba = map.to_rgba_image(&regions);
    /// assert_eq!(rgba.len(), (map.width * map.height * 4) as usize);
    /// ```
    #[must_use]
    pub fn to_rgba_image(&self, regions: &[Region]) -> Vec<u8> {
        // Создаём маппинг region_id → цвет для эффективного поиска
        let mut colors = HashMap::new();

        // Добавляем цвета для всех регионов
        for reg in regions {
            // Извлекаем компоненты из HEX-строки "#rrggbb"
            let hex = &reg.color[1..]; // убираем '#'
            if hex.len() == 6
                && let (Ok(r), Ok(g), Ok(b)) = (
                    u8::from_str_radix(&hex[0..2], 16),
                    u8::from_str_radix(&hex[2..4], 16),
                    u8::from_str_radix(&hex[4..6], 16),
                )
            {
                colors.insert(reg.id, [r, g, b, 255]); // альфа = 255 (непрозрачный)
            }
        }

        // Цвет по умолчанию для неотнесённых пикселей:
        // Тёмно-синий [20, 20, 60] — визуально выделяет проблемные области,
        // но не сливается с чёрным фоном
        let default_color = [20, 20, 60, 255];

        // Преобразуем каждый пиксель в RGBA
        self.data
            .iter()
            .flat_map(|&rid| colors.get(&rid).copied().unwrap_or(default_color))
            .collect()
    }

    /// Сохраняет карту регионов в PNG-файл
    ///
    /// # Параметры
    /// * `path` — путь к файлу для сохранения (например, `"output/regions.png"`)
    /// * `regions` — список регионов для получения цветов
    ///
    /// # Ошибки
    /// Возвращает ошибку в случае:
    /// - Невозможно создать буфер изображения (некорректные размеры)
    /// - Невозможно записать файл (нет прав, недостаточно места и т.д.)
    ///
    /// # Пример
    /// ```rust
    /// region_map.save_as_png("output/regions.png", &regions)?;
    /// ```
    pub fn save_as_png(
        &self,
        path: &str,
        regions: &[Region],
    ) -> Result<(), Box<dyn std::error::Error>> {
        let rgba_data = self.to_rgba_image(regions);
        let img: ImageBuffer<Rgba<u8>, Vec<u8>> =
            ImageBuffer::from_raw(self.width, self.height, rgba_data)
                .ok_or("Failed to create image buffer")?;
        img.save(path)?;
        Ok(())
    }
}
